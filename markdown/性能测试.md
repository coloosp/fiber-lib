# æ€§èƒ½æµ‹è¯•
## æµ‹è¯•å‡†å¤‡
æˆ‘ä»¬çš„å‹åŠ›æµ‹è¯•ä½¿ç”¨ApacheBench
Debian/Ubuntu:`sudo apt-get install apache2-utils`
CentOS/RHEL:`sudo yum install httpd-tools`

å®‰è£…å¥½åä½¿ç”¨`ab -V`æ£€æŸ¥ï¼š
![](vx_images/166994437226030.png)
å®‰è£…å¥½åå†è¿›è¡Œä¸‹é¢çš„æµ‹è¯•

## åç¨‹åº“hook
ä»¥ä¸‹ç³»ç»Ÿå‡½æ•°éƒ½æ˜¯hookåçš„å‡½æ•°ï¼Œå¯ä»¥å®ç°å¯¹æ•°æ®æœªå°±ç»ªsocketçš„æŒ‚èµ·
```
#include "ioscheduler.h"
#include "hook.h"
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <iostream>
#include <stack>
#include <cstring>
#include <chrono>
#include <thread>

//å…¨å±€å˜é‡ï¼Œç›‘å¬å¥—æ¥å­—æ–‡ä»¶æè¿°ç¬¦
static int sock_listen_fd =-1;

//å¤„ç†å®¢æˆ·ç«¯è¿æ¥äº‹ä»¶
void test_accept();

//é”™è¯¯å¤„ç†å‡½æ•°
void error(const char *msg)
{
    perror(msg); //æ‰“å°ç³»ç»Ÿé”™è¯¯ä¿¡æ¯
    printf("error...\n");
    exit(1);//é€€å‡ºç¨‹åº
}

//ç›‘å¬IOè¯»äº‹ä»¶
void watch_io_read()
{
    sylar::IOManager::GetThis()->addEvent(sock_listen_fd,sylar::IOManager::READ,test_accept);
}

//å¤„ç†å®¢æˆ·ç«¯è¿æ¥äº‹ä»¶
void test_accept()
{
    //å®¢æˆ·ç«¯åœ°å€ç»“æ„ä½“
    struct sockaddr_in addr;
    memset(&addr,0,sizeof(addr));//åˆå§‹åŒ–åœ°å€ç»“æ„ä½“ä¸º0

    socklen_t len =sizeof(addr);

    //è¿™é‡Œçš„acceptå·²ç»æ˜¯hookåçš„acceptäº†
    int fd =accept(sock_listen_fd,(struct sockaddr*)&addr,&len);

    //acceptå¤±è´¥
    if(fd <0)
    {
        std::cout <<"accept å¤±è´¥,fd=" <<fd <<",errno =" <<errno <<std::endl;
    }
    else
    {
        std::cout <<"æ¥æ”¶åˆ°è¿æ¥,fd =" <<fd <<std::endl;

        //è®¾ç½®å®¢æˆ·ç«¯fdä¸ºéé˜»å¡æ¨¡å¼
        fcntl(fd,F_SETFL,O_NONBLOCK);

        //ä¸ºå®¢æˆ·ç«¯fdæ·»åŠ READäº‹ä»¶,å›è°ƒå‡½æ•°ä¸ºlambdaè¡¨è¾¾å¼
        sylar::IOManager::GetThis()->addEvent(fd,sylar::IOManager::READ,[fd]()
        {
            char buffer[1024];//æ¥æ”¶ç¼“å†²åŒº
            memset(buffer,0,sizeof(buffer));

            //å¾ªç¯è¯»å–å®¢æˆ·ç«¯æ•°æ®
            while(true)
            {
                //æ¥æ”¶å®¢æˆ·ç«¯æ•°æ®ï¼Œ0æ˜¯flags
                int ret =recv(fd,buffer,sizeof(buffer),0);

                if(ret >0)
                {
                    std::cout <<"æ¥æ”¶åˆ°ä¿¡æ¯,fd=" <<fd<<",data=" <<buffer <<std::endl;
                    
                    //HTTPæˆåŠŸå“åº”çŠ¶æ€ç ï¼Œè¿”å›Nice try!
                    const char *response ="HTTP/1.1 200 OK\r\n"
                                           "Content-Type: text/plain\r\n"    
                                           "Content-Length: 10\r\n"          //è¡¨ç¤º9å­—èŠ‚
                                           "Connection: keep-alive\r\n"      
                                           "\r\n"                            
                                           "Nice  try!";                  
                

                //å‘é€HTTPå“åº”
                ret=send(fd,response,strlen(response),0);

                close(fd);
                break;
                }

                 //è¯»å–æ•°æ®å¤±è´¥æˆ–è¿æ¥å…³é—­
                if(ret <=0)
                  {   
                //å®¢æˆ·ç«¯å…³é—­æˆ–å‘é€éEAGAIN(èµ„æºæš‚æ—¶ä¸å¯ç”¨)é”™è¯¯
                if(ret ==0 || errno!=EAGAIN)
                {
                   std::cout <<"å…³é—­è¿æ¥,fd=" <<fd <<std::endl;
                   close(fd);
                   break;
                }
                else if(errno==EAGAIN)//èµ„æºæš‚æ—¶ä¸å¯ç”¨
                {
                    //åˆ«ç€æ€¥ï¼Œåç¨‹ä¼šè‡ªå·±æŒ‚èµ·
                    std::cout <<"èµ„æºæš‚æ—¶ä¸å¯ç”¨,fd=" <<fd <<std::endl;
                    // std:::this_thread::sleep_for(std::chrono::milliseconds(50));//å»¶è¿Ÿä¼‘çœ æ—¶é—´ï¼Œé¿å…ç¹å¿™ç­‰å¾…
                }
            }
            }//while(true) å¾ªç¯è¯»å–
    });//addEvent lambda
    }//else æˆåŠŸè¿æ¥
    //è§¦å‘äº‹ä»¶åé‡æ–°å†æ‰‹åŠ¨æ·»åŠ ï¼Œå› ä¸ºæˆ‘ä»¬æ¯æ¬¡ä¼šç§»é™¤äº‹ä»¶å¹¶è§¦å‘å›è°ƒå‡½æ•°
    sylar::IOManager::GetThis()->addEvent(sock_listen_fd,sylar::IOManager::READ,test_accept);
}


//IOè°ƒåº¦å™¨æµ‹è¯•å‡½æ•°
void test_iomanager()
{
    int portno =8080;//æœåŠ¡å™¨ç›‘å¬ç«¯å£
    struct sockaddr_in server_addr,client_addr;//æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯åœ°å€
    socklen_t client_len =sizeof(client_addr);//å®¢æˆ·ç«¯åœ°å€é•¿åº¦

    //åˆ›å»ºTCPå¥—æ¥å­—ï¼Œä¼ å…¥IPv4ï¼ŒTCPåè®®ï¼Œé»˜è®¤åè®®
    //hookåçš„socketä¼šè‡ªåŠ¨åˆ›å»ºfdä¸Šä¸‹æ–‡
    sock_listen_fd =socket(AF_INET,SOCK_STREAM,0);

    if(sock_listen_fd <0)
    {
        error("å¤±è´¥åˆ›å»ºsocket..\n");
    }

    //è§£å†³"address already in use"é”™è¯¯ï¼Œè®¾ç½®ç«¯å£å¤ç”¨
    int yes =1;
    setsockopt(sock_listen_fd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes));

    //åˆå§‹åŒ–æœåŠ¡å™¨åœ°å€ç»“æ„ä½“
    memset((char*)&server_addr,0,sizeof(server_addr));
    server_addr.sin_family =AF_INET;//åœ°å€æ—IPv4
    server_addr.sin_port =htons(portno);//ç«¯å£å·
    server_addr.sin_addr.s_addr = INADDR_ANY;//ç»‘å®šæ‰€æœ‰ç½‘å¡IP

    //ç»‘å®šå¥—æ¥å­—å¹¶ç›‘å¬è¿æ¥,è¿™é‡Œå¹¶éç»‘å®šå›è°ƒçš„std::bind
    if(bind(sock_listen_fd,(struct sockaddr *)&server_addr,sizeof(server_addr)) <0)
        error("ç»‘å®šå¥—æ¥å­—é”™è¯¯...\n");

        //ç›‘å¬è¿æ¥
    if(listen(sock_listen_fd,1024) <0)
    {
        error("ç›‘å¬è¿æ¥é”™è¯¯...\n");
    }

    printf("epoll echo server listening for connections on port :%d\n",portno);

    fcntl(sock_listen_fd,F_SETFL,O_NONBLOCK);//è®¾ç½®ç›‘å¬fdä¸ºéé˜»å¡æ¨¡å¼

    sylar::IOManager iom(2);// 2ä¸ªå·¥ä½œçº¿ç¨‹ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘çš„æœåŠ¡å™¨æœ‰ç‚¹åƒåœ¾ï¼Œå„ä½å¯ä»¥æ ¹æ®è‡ªå·±çš„æœåŠ¡å™¨å†³å®šæœ€ä½³çº¿ç¨‹æ•°

    //æœ‰å®¢æˆ·ç«¯è¿æ¥æ—¶è§¦å‘test_acceptå›è°ƒ
    iom.addEvent(sock_listen_fd,sylar::IOManager::READ,test_accept);
}

int main(int argc,char *argv[])
{
    test_iomanager();
    return 0;
}

```
è¿™æ˜¯æˆ‘çš„æœåŠ¡å™¨IPåœ°å€
![](vx_images/110745471807970.png)
åœ¨è¿è¡ŒæœŸé—´ç”¨æµè§ˆå™¨è®¿é—®è¿™ä¸ªç½‘å€å°±å¯ä»¥çœ‹åˆ°`http://47.86.55.223:8080/`
æ³¨æ„è¿™æˆ‘çš„æœåŠ¡å™¨ç½‘ç«™ï¼Œå¦‚æœå„ä½åœ¨æœ¬æœºä¸Šæµ‹è¯•å°±åº”è¯¥æ˜¯127.0.0.1:8080
### ç®€å•æµ‹è¯•
![](vx_images/320473830806944.png)

Nice try!ä¸é”™çš„å°è¯•

ä¸è¿‡æˆ‘å»ºè®®å¤§å®¶åœ¨è¿›è¡Œå‹æµ‹æ—¶å…³é—­debugï¼Œä¸å¦‚ä½ ä¼šçœ‹åˆ°ä½ çš„æœåŠ¡å™¨å†™çˆ†äº†å„ç§debugæ‰“å°
### é«˜å¹¶å‘æµ‹è¯•
`ab -n 1000 -c 100 http://47.86.55.223:8080/`
![](vx_images/75294670380063.png)
### æŒç»­å‹åŠ›æµ‹è¯•
ç›´æ¥å‘æœåŠ¡å™¨ç”³è¯·ä¸€ä¸‡æ¬¡è®¿é—®
`ab -n 10000 -c 500 http://47.86.55.223:8080/`
![](vx_images/174523727758033.png)
## åŸç”Ÿepoll
ä»¥ä¸‹å‡½æ•°éƒ½æ˜¯æœªhookçš„ç³»ç»ŸåŸå§‹å‡½æ•°ï¼Œä»…ä»…ä½¿ç”¨äº†åŸç”Ÿepollå®ç°
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define MAX_EVENTS 10 
#define PORT 8080

//å› ä¸ºä¸åœ¨ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œä»¥ä¸‹å‡½æ•°å‡ä¸ºç³»ç»ŸåŸå§‹å‡½æ•°ï¼Œéhookåçš„å‡½æ•°
int main()
{
    //åˆ†åˆ«æ˜¯ç›‘å¬socketï¼Œå®¢æˆ·ç«¯socket,epollå®ä¾‹çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä¸åœ¨epoll_waitä¸­è¿”å›çš„å°±ç»ªäº‹ä»¶æ•°
    int listen_fd,conn_fd,epoll_fd,event_count;

    struct sockaddr_in server_addr,client_addr; //åœ°å€ç»“æ„ä½“
    socklen_t addr_len =sizeof(client_addr); 

    struct epoll_event events[MAX_EVENTS],event;//epoll_eventæ•°ç»„å’Œepoll_eventå®ä¾‹

    if((listen_fd =socket(AF_INET,SOCK_STREAM,0)) ==-1)
    {
        perror ("socket");//ç³»ç»Ÿé”™è¯¯æ‰“å°å‡½æ•°
        return -1;
    }

    int yes =1;
    setsockopt(listen_fd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes));


    //åˆå§‹åŒ–æœåŠ¡å™¨ç»“æ„ä½“
    memset(&server_addr,0,sizeof(server_addr));
    server_addr.sin_family=AF_INET; //IPv4
    server_addr.sin_port =htons(PORT); //ç«¯å£8080
    server_addr.sin_addr.s_addr =INADDR_ANY; //ç»‘å®šæ‰€æœ‰ç½‘å¡

    //ç»‘å®šç›‘å¬socketåˆ°æŒ‡å®šç«¯å£
    if(bind(listen_fd,(struct sockaddr*)&server_addr,sizeof(server_addr))==-1)
    {
        perror("bind");
        return  -1;
    }

    //ç›‘å¬è¿æ¥
    if(listen(listen_fd,1024) ==-1)
    {
        perror("listen");
        return -1;
    }

    //åˆ›å»ºepollå®ä¾‹ï¼Œepoll_creat1ä¸ºepoll_createçš„å¢å¼ºç‰ˆï¼Œ0è¡¨ç¤ºé»˜è®¤é…ç½®
    if((epoll_fd =epoll_create1(0))==-1)
    {
        perror("epoll_create1");
        return -1;
    }

    //è®¾ç½®epoll_event
    event.events =EPOLLIN;//ç›‘å¬äº‹ä»¶ä¸ºè¯»äº‹ä»¶
    event.data.fd =listen_fd;//å…³è”ç›‘å¬å¥—æ¥å­—

    //å°†epoll_eventæ·»åŠ åˆ°epoll
    if(epoll_ctl(epoll_fd,EPOLL_CTL_ADD,listen_fd,&event)==-1)
    {
        perror("epoll_ctl");
        return -1;
    }

    //æ ¸å¿ƒé€»è¾‘
    while(true)
    {
        //ç­‰å¾…æœ‰å°±ç»ªäº‹ä»¶å‘ç”Ÿï¼Œæ˜¯ä¸æ˜¯å’Œæˆ‘ä»¬çš„idleå‡½æ•°é‚£è¾¹å¾ˆåƒï¼Ÿ
        event_count =epoll_wait(epoll_fd,events,MAX_EVENTS,-1);

        if(event_count ==-1)
        {
            perror("epoll_wait");
            return -1;
        }

        //éå†æ‰¾å‡ºæ‰€æœ‰å°±ç»ªäº‹ä»¶
        for(int i=0;i<event_count;i++)
        {   
            //å¦‚æœè¿™ä¸ªä½ç½®æ˜¯è¿æ¥äº‹ä»¶ï¼Œå°±æ·»åŠ ç›‘å¬æ•°æ®çš„äº‹ä»¶
            if(events[i].data.fd ==listen_fd)
            {
                conn_fd =accept(listen_fd,(struct sockaddr*)&client_addr,&addr_len);
                if(conn_fd ==-1)
                {
                    perror("accept");
                    continue; //å½“å‰é”™è¯¯è¿æ¥ï¼Œæ¥ç€å¤„ç†ä¸‹ä¸€ä¸ªäº‹ä»¶
                }

                event.events =EPOLLIN; //è¯»äº‹ä»¶
                event.data.fd =conn_fd;//ç›‘å¬å®¢æˆ·ç«¯
                if(epoll_ctl(epoll_fd,EPOLL_CTL_ADD,conn_fd,&event) ==-1)
                {
                    perror("epoll_ctl");
                    return -1;
                }
            }
            else //è¯»æ•°æ®äº‹ä»¶
            {
                char buf[1024];
                //è¯»å–å®¢æˆ·ç«¯æ•°æ®
                int len =read(events[i].data.fd,buf,sizeof(buf)-1);
                
                //è¯»å–å¤±è´¥æˆ–è€…å®¢æˆ·ç«¯å…³é—­è¿æ¥
                if(len <=0)
                {
                    close(events[i].data.fd);
                }
                else //è¯»å–åˆ°æ•°æ®
                {
                    //HTTPå“åº”ï¼Œæ‰“å‡ºGG
                    const char *response ="HTTP/1.1 200 OK\r\n"
                                          "Content-Type: text/plain\r\n"
                                          "Content-Length:10\r\n"
                                          "Connection: keep-alive\r\n"
                                          "\r\n"
                                          "Good Game!";

                    write(events[i].data.fd,response,strlen(response));

                    close(events[i].data.fd);
                }
            }
        }
    }
    close(listen_fd);
    close(epoll_fd);
    return 0;
}
```

å€¼å¾—ä¸€æçš„æ˜¯åŸç”Ÿepollå¹¶ä¸èƒ½å®ç°å¤šçº¿ç¨‹ä¹Ÿæ²¡æœ‰åç¨‹ç­‰å¾…ï¼Œè¿™æ˜¯epollçš„å›ºæœ‰é—®é¢˜
### ç®€å•æµ‹è¯•
è®¿é—®åŒæ ·çš„ç½‘ç«™å³å¯`http://47.86.55.223:8080/`
![](vx_images/118176333296498.png)
Good Gameï¼
### é«˜å¹¶å‘æµ‹è¯•
`ab -n 1000 -c 100 http://47.86.55.223:8080/`
![](vx_images/470167847822839.png)
### æŒç»­å‹åŠ›æµ‹è¯•
`ab -n 10000 -c 500 http://47.86.55.223:8080/`
![](vx_images/319075495997900.png)




ä¸€èˆ¬æˆ‘ä»¬ä¼šæ¯”è¾ƒä¸¤è€…çš„Requests per secondï¼ˆååç‡ï¼‰å¤§å°æ¥æ¯”ä»·æ€§èƒ½ï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„åç¨‹åº“è¢«epollæ‰“çˆ†äº†ğŸ˜­
å› ä¸ºä½œè€…çš„æœåŠ¡å™¨æ˜¯å‡ åå—é’±ä¾¿å®œç§Ÿçš„ï¼Œå‹æ ¹å°±æ²¡æœ‰å¤šä½™çš„ç‰©ç†æ ¸ï¼Œè¿™ç§æƒ…å†µå¤šçº¿ç¨‹åè€Œä¼šæˆä¸ºè´Ÿæ‹…ï¼Œå¹¶ä¸”æˆ‘ä»¬åªæ˜¯å‘é€äº†ç®€å•çš„ç½‘ç»œè¯·æ±‚ï¼Œè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬çš„åç¨‹åº“å®é™…ä¸Šæ²¡æœ‰ä»»ä½•ä¼˜åŠ¿


## æ·»åŠ é˜»å¡é€»è¾‘
è¯·æ³¨æ„ï¼Œä½œè€…å¹¶ä¸çŸ¥é“è¿™æ ·çš„æµ‹è¯•æ¡ˆä¾‹æ˜¯å¦æ­£ç¡®ï¼Œå› ä¸ºæˆ‘ä¸ä¼šå†™æµ‹è¯•ï¼
æˆ‘çš„æ€è·¯æ˜¯å› ä¸ºç½‘ç»œè¯·æ±‚è¿‡äºç®€å•ï¼Œä¸ä¼šæœ‰é˜»å¡å‘ç”Ÿï¼Œé‚£è¿™æ ·æˆ‘ä»¬çš„åç¨‹åº“è‚¯å®šæ¯”ä¸è¿‡epollã€‚è¯¶ï¼Œæ²¡æœ‰é˜»å¡æˆ‘åˆ›é€ é˜»å¡ä¸å°±è¡Œäº†
å¯¹äºåç¨‹åº“æˆ‘ä»¬æ·»åŠ äº†ç³»ç»ŸåŸå§‹å‡½æ•°` usleep_f(1000);`
å¹¶ä¸”åœ¨epollé‡Œé¢æ·»åŠ äº†`usleep(1000);`
åˆ†åˆ«åœ¨ä»¥ä¸‹ä½ç½®
![](vx_images/105423170649494.png)
![](vx_images/326882771401538.png)

æ¥çœ‹çœ‹å·®åˆ«å§
### åç¨‹åº“ï¼š
   * é«˜å¹¶å‘æµ‹è¯•  
    ![](vx_images/428802238902694.png)
   * æ¨¡æ‹ŸæŒç»­å‹åŠ›æµ‹è¯•  
    ![](vx_images/2766034304041.png)
    
### åŸç”Ÿepoll
* é«˜å¹¶å‘æµ‹è¯•
    ![](vx_images/45444569212449.png)
* æ¨¡æ‹Ÿå‹åŠ›æµ‹è¯•
![](vx_images/276375172468217.png)

### æ€§èƒ½å¯¹æ¯”
é€šè¿‡ååé‡å¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„åç¨‹åº“è¿˜æ˜¯é«˜å‡ºä¸€æˆªçš„

| æµ‹è¯•åœºæ™¯          | å¹¶å‘æ•° | æŒ‡æ ‡              | åç¨‹åº“ (2çº¿ç¨‹) | åŸç”Ÿ epoll (å•çº¿ç¨‹) | æå‡/å˜åŒ–   |
| :--------------- | :----- | :--------------- | :------------ | :----------------- | :--------- |
| **é«˜å¹¶å‘æµ‹è¯•**   | 100    | QPS (req/s)      | **1029.67**   | 820.15             | **+25.5%** |
|                  |        | å¹³å‡å“åº”æ—¶é—´ (ms) | 97.118        | 121.928            | **-20.3%** |
| **æŒç»­å‹åŠ›æµ‹è¯•** | 500    | QPS (req/s)      | **1162.88**   | 861.47             | **+35.0%** |
|                  |        | å¹³å‡å“åº”æ—¶é—´ (ms) | 429.968       | 580.405            | **-25.9%** |

æ‰€è°“æœ¯ä¸šæœ‰ä¸“æ”»ï¼Œæˆ‘ä»¬çš„åç¨‹åº“åœ¨å®ç°æ›´å¤šé˜»å¡æ—¶æ€§èƒ½è¿˜æ˜¯æ¯”epollå‰å®³äº›çš„

### libevent
è¿˜æœ‰ä¸€ä¸ªCè¯­è¨€äº‹ä»¶é€šçŸ¥åº“ï¼Œå„ä½å¦‚æœæœ‰å…´è¶£å¯ä»¥è¯•è¯•
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <event2/event.h>
#include <event2/listener.h>
#include <event2/bufferevent.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080

// å¤„ç†è¯»äº‹ä»¶çš„å›è°ƒå‡½æ•°
void http_read_cb(evutil_socket_t fd, short events, void *arg) {
    char buf[1024];
    int len = recv(fd, buf, sizeof(buf) - 1, 0);
    if (len <= 0) {
        // å‘ç”Ÿé”™è¯¯æˆ–è¿æ¥å…³é—­ï¼Œå…³é—­è¿æ¥å¹¶é‡Šæ”¾äº‹ä»¶èµ„æº
        close(fd);
        event_free((struct event *)arg);
        return;
    }
    buf[len] = '\0';
    printf("æ¥æ”¶åˆ°æ¶ˆæ¯ï¼š%s\n", buf);

    // æ„å»ºHTTPå“åº”
    const char *response = "HTTP/1.1 200 OK\r\n"
                           "Content-Type: text/plain\r\n"
                           "Content-Length: 10\r\n"
                           "Connection: keep-alive\r\n"
                           "\r\n"
                           "Good Luck!";
    send(fd, response, strlen(response), 0);

    // å‘é€å“åº”åå…³é—­è¿æ¥
    close(fd);
    event_free((struct event *)arg);
}

// æ¥å—è¿æ¥çš„å›è°ƒå‡½æ•°
void accept_conn_cb(evutil_socket_t listener, short event, void *arg) {
    struct event_base *base = (struct event_base *)arg;
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);
    int fd = accept(listener, (struct sockaddr *)&ss, &slen);
    if (fd < 0) {
        perror("accept");
    } else if (fd > FD_SETSIZE) {
        close(fd);
    } else {
        // åˆ›å»ºä¸€ä¸ªæ–°çš„äº‹ä»¶ç»“æ„ä½“
        struct event *ev = event_new(NULL, -1, 0, NULL, NULL);
        // å°†æ–°çš„äº‹ä»¶æ·»åŠ åˆ°äº‹ä»¶å¾ªç¯ä¸­
        event_assign(ev, base, fd, EV_READ | EV_PERSIST, http_read_cb, (void *)ev);
        event_add(ev, NULL);
    }
}

int main() {
    struct event_base *base;
    struct event *listener_event;
    struct sockaddr_in sin;

    // åˆå§‹åŒ–ç›‘å¬åœ°å€å’Œç«¯å£
    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(INADDR_ANY);
    sin.sin_port = htons(PORT);

    // åˆ›å»ºç›‘å¬å¥—æ¥å­—
    int listener = socket(AF_INET, SOCK_STREAM, 0);
    if (listener < 0) {
        perror("socket");
        return -1;
    }

    // è®¾ç½®å¥—æ¥å­—é€‰é¡¹ï¼Œå…è®¸åœ°å€å¤ç”¨
    evutil_make_socket_nonblocking(listener);
    int reuse = 1;
    setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

    // ç»‘å®šåœ°å€å’Œç«¯å£
    if (bind(listener, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
        perror("bind");
        return -1;
    }

    // ç›‘å¬ç«¯å£
    if (listen(listener, 1024) < 0) {
        perror("listen");
        return -1;
    }

    // åˆå§‹åŒ–Libeventåº“
    base = event_base_new();

    // åˆ›å»ºä¸€ä¸ªç›‘å¬äº‹ä»¶
    listener_event = event_new(base, listener, EV_READ | EV_PERSIST, accept_conn_cb, (void *)base);

    // å°†ç›‘å¬äº‹ä»¶æ·»åŠ åˆ°äº‹ä»¶å¾ªç¯ä¸­
    event_add(listener_event, NULL);

    // å¼€å§‹äº‹ä»¶å¾ªç¯
    event_base_dispatch(base);

    // æ¸…ç†èµ„æº
    event_free(listener_event);
    event_base_free(base);
    close(listener);

    return 0;
}
```