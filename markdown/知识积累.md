# 知识积累
各位下午好，这里是记录我学习协程库并且逐步实现的文档，话不多说我们开始准备吧
[STL](https://io.zouht.com/154.html)可以快速通过这个网站了解STL知识
## 指针与函数指针
虽然我们在数据结构里面写了很多很多指针，不过稍微再试着深刻理解一下吧，首先指针一般是这样命名的 数据类型* 指针名，因为代码简短我们可以试着实现一下
```
int a=5;
int* p=&a;
cout <<*p;//输出5
```
比如这样就实现了解引用，如果一个指针是指向了结构体或者类，它可以这样做、
```
LNode *p=new LNode;//实际上应该无所谓给这个指针分配了一个匿名对象的地址
p->val=233;
cout << p->val;//输出233
//或者这样做
LNode node;
node.val=666;
p=&node;//给这个p分配node的地址
cout <<p->val;//输出的是666
//或者吃饱了撑可以这样做
cout << (*p).val;//输出的是666,要小心需要添加括号
```
对于指针掌握到这种程度也足够了，接下来是函数指针
函数指针的写法是这样的`返回类型 (*函数指针名)（参数列表）=函数名`仔细看和指针的区别就是多了参数列表，在调用时有两种方法，直接调用 函数指针(传入参数)
解引用调用 （*函数指针)(传入参数),虽然两个小括号看起来有些奇怪。
还有就是类函数指针，写法是这样的
`返回类型 （类名::*函数指针名）=&类名::成员函数名`，这样确实是需要&符号的，接下去区分静态成员函数和非静态成员函数，对于非静态成员函数，自然是每个对象独特的，我们需要这样做`(对象.*函数指针)(参数列表)`，或者使用对象指针来调用`（对象指针->*函数指针）  
(参数列表)`，刚开始感觉两个小括号的形式还是有点不熟悉。对于静态成员函数就可以直接调用，毕竟静态成员函数并不属于哪一个对象，`(*函数指针)(参数列表)`

对于这样的写法貌似有点麻烦，我们似乎可以使用typedef的形式来简化
```
typedef 返回类型（*函数指针别名）(对应参数列表);

函数指针别名 函数指针名=函数名;

//也可以这样实现
typedef 返回类型 (函数别名)(对应参数列表);

函数别名* 函数指针名=函数;

//类函数指针同样可以这样实现
typedef 返回类型 （类名::*别名）(对应成员函数参数列表);
```
不过貌似现在更通用的写法好像是using，我们之前也见到过`using namespace std`
```
using 别名=返回类型(*)(参数列表);
//对于类函数指针来说也非常简单
using 别名=返回类型(类名::*)(参数列表);//这是对于非静态成员函数
using 别名=返回类型(*)(参数列表); //这是对于静态成员函数
```


## 面向对象
写了太久的面向过程的代码我连这个都快忘了，稍微说明一点给自己听。
类里面包含成员变量和成员函数，当然也有不同的访问权限，对于成员函数可以在类里面实现，当然也可以通过
`类名 :: 成员函数名`这样的方法在外部实现，对应构造对象一般通过这样的方法`类名 对象名`这样构造出来的对象里面的参数还没有被赋值，我们也可以构造对象时给它赋值，这就需要我们在类里面实现有参的构造函数
一般我应该会这样去实现一个有参构造函数
```
类名(数据类型 成员变量_): 成员变量（成员变量_）{}
```
我们也可以通过这样的方式实现指向对象的指针
`类名* 指针名=new 构造函数 ()`
额，我以前经常会错误的去实现这样的指针，即`类名* 指针名`，这样当然也是实现了一个指向对应数据类型的指针，但它并不能使用`指针名->成员变量`这样的方式，因为我们并没有给它分配地址,这个叫做野指针

还有就是析构函数，也就是~类名，一般编译器会自动给出析构函数，当然也可以自己实现，析构函数我见到的用处不算多，等有用的时候再补充吧

然后是稍微高级一些的，比如虚函数，虚函数是在类里面的成员函数加上virtual也就是`virtual 返回类型 函数名()`这样的函数可以实现也可以不实现`virtual 返回类型 函数名()=0`，不实现的话就会变成纯虚函数，如果一个类里面存在一个纯虚函数，这样的类就是抽象类，抽象类是不能构造对象的，也就是实例化。我们可以使用子类去继承上面的类`class 子类名: public 父类名`，对于虚函数我们可以实现也可以不实现，实现的话需要这样做
`数据类型 函数名() override`注意数据类型和函数名必须相同，这样的操作也就是函数重写，当子类继承了抽象类就必须重写（实现）所有纯虚函数，否则这个子类也会变成抽象类
### 回调函数
回调函数是把函数当成可传入的变量，这样就可以在其他函数或者其他地方执行相应的函数。 与函数指针的思想类似。
语法一般是`std::functional<函数签名>`
函数签名指函数返回值类型(传入参数类型)
具体用法
```
void F(std::functional<int(int)> f){
    
}//在F函数中传入了一个返回值为int，传入参数为int的回调函数

```

## 智能指针
智能指针是为了解决C++里面内存泄漏的问题，也就是一个指针在分配使用完对应内存后没有得到释放的问题
### unique_ptr  
unique_ptr的构造方式如下  
`unique_ptr<类名> 指针名=make_unique<类名>(参数列表)`
当然智能指针在调用时和指针几乎一样,都可以使用->的方法访问成员
```
unique_ptr <Demo> up1=make_unique<Demo>(123);
cout <<up->val;
//同样的应该可以实现以下
cout <<(*up).val;
```
`unique_ptr`顾名思义，只能有一个这种指针管理对应的内存，如果想要让新的指针指向这片内存必须使用`move`函数
```
//接上
unique_ptr <Demo> up2;
up2=move(up);
cout << up2->val;
cout <<up->val;//不行，这个指针已经空了
```
值得一提的是`unique_ptr`对结构体也是起效的，对于`unique_ptr`来说最好不要接管栈上已存在的对象
### shared_ptr  与weak_ptr
`shared_ptr`相较于`unique_ptr`来说，可以有多个`shared_ptr`指向同一片内存，当然`shared_ptr`也可以被拷贝,`shared_ptr`的构造方式类似
```
shared_ptr<Demo> sp1=make_shared<Demo>(构造函数参数列表);
shared_ptr sp2=sp1;//对于unique_ptr就只能使用move转移控制权了
```
不同`shared_ptr`指向同一片内存会维护一个计数器，当增加一个`shared_ptr`时计数器加一，反过来当离开作用域或者一个`shared_ptr`被销毁时计数器会减一。当计数器归零时指向的内存就会释放

不过会产生一个尴尬的问题，循环引用，当多个`shared_ptr`互相指向时对方，形成类似强连通图时，会导致即使离开作用域，计数器也可能不为0导致内存无法被成功释放

为此引入了`weak_ptr`，`weak_ptr`貌似并没有`make_weak`的方法了，不过它可以拷贝`shared_ptr`，并指向`shared_ptr`指向的内存，例如
```
weak_ptr <Demo> wk=sp1;//接上
```
`weak_ptr`并不能直接访问，需要转换为`shared_ptr`才能访问
```
if(!wp.expired()){//确保指向的内存没有被释放
    
shared_ptr <Demo> sp3=wp.lock();
cout <<sp3->val;

}
```

额外 智能指针可以通过调用`get()`来直接获取其裸指针形式

## lambda表达式
lambda表达式是一种定义匿名函数的方法，它由以下几个部分构成
1. [] 捕获，用于捕获外部变量
2. () 参数列表
3. mutable 标出时说明捕获值可修改
4. -> 返回类型 函数返回类型，不写时可自动推导
5. 函数体
具体格式是`[捕获变量](参数列表)mutable ->返回类型{函数体}`  
对于捕获变量有两种形式，按值和按引用。当按值时除非加上`mutable`否则捕获的外部变量在函数内部不可修改，类似`const`?
按引用时,函数内部可修改，和常规函数一样，这样做会影响到外部变量。
也存在简化的捕获，比如[=]表示全部按值，[&]表示全部按引用，也可以这样写[=,&x]表示除了x按引用其他全部按值
```
float x=2.5;
float y=3;
cout << [=,&x](int a,int b)->float{
    x++;
    return a*x*b*y;
}(1,2)<<endl;//应该是输出的21

cout <<x <<endl;//这里的是3.5
//也可以使用auto将其显化
auto p=[=](int a,int b)->int{return a+b};
cout <<p(1,2)<< endl;//应该是输出的是3
```
## 模板
### 函数模板
函数模板是为了解决对于各种不同数据类型的处理问题，比如最简单的swap函数，普通函数只能处理一种数据类型的函数，但函数模板可以实现不同数据类型的交换
函数模板的格式一般是
```
template<typename T>//按道理typename替换为class也可以实现相同的效果
T maxval(T a,T b){
    return a>b?a:b;
}//这个函数模板就在实现返回最大值的功能

//隐式实例化
int a=2;
int b=1;
cout <<maxval(a,b) <<endl;//输出2

float x=2.5;
float y=1.5;
cout << maxval(x,y) <<endl;//输出2.5

//显示实例化

cout << maxval<int>(a,b) <<endl;//输出2
cout << maxval<float>(a,b) <<endl;//这样也是对的，会将a和b转化为浮点型并输出,结果为2.0
```

对于函数模板也可以进行重载，函数模板重载后仍然是模板
```
template <typename T>
T maxval(T a,T b,T c){
 if (a > b) {
        if (a > c) {
            return a;
        } else { 
            return c;
        }
    } else {
        if (b > c) {
            return b;
        } else { 
            return c;
        }
    }
}//就可以实现三个数的大小比较了

cout <<maxval(1,2,3) <<endl;//输出3
```
当然也可以实现函数模板的特化，注意这不等于写了普通函数也不是写了特殊的函数模板，而是进行的函数模板的实例化
```
template <>
double maxval<double>(double a,double b){
    cout <<"这里是浮点型的专属最大值函数"<<endl;
    return a>b?a:b;
}

cout <<maxval(3.0,2.0) <<endl;//输出对应文本以及3.0
```
对于编译器来说，执行的顺序会是普通函数->模板特化->更具体的模板(重载模板)->普通模板，如果执行的是隐式实例化的话

### 类模板
和函数模板相似类模板的语法如下：
```
template <typename T>
class 类名{
private:
T 成员变量;
public:
类名(T 参数)：成员变量(参数) {}//这里是构造函数
T 成员函数(){
    return 成员变量;
}//这里是获取成员变量的成员函数

};
```
对于类模板只能进行显式构造，也就是必须显式指示出T的数据类型
```
template <typename T>
class Shape{
private:
T radius;
public:
Shape (T r): radius(r) {}
T getRadius(){
    return radius;
}
    
};
Shape <int> circle(10);
cout <<circle.getRadius() <<endl;//输出结果为10

```
同样类模板也可以特化，并且分为全特化和部分特化，部分特化构造对象时要注意多种部分特化可能会导致二义性。这里主要说明全特化,全特化首先要实现类模板的全部，也可以添加自己的成员变量和修改成员函数
```
template <>
class Shape<double>{//这里要标注出对应T的数据类型
private:
double radius;
int area;//也可以添加新的成员变量
public:
Shape (double r,int area_): radius(r),area(area_){}
double getRadius(){
    cout <<"这里是double类型类模板特化！"<<endl;
    return radius;
}
int getArea();//仅仅是函数声明

};

int Shape<double>:: getArea(){
    cout <<"这里是类成员函数类外定义" <<endl;
    return area;
}

Shape <double> square(10.0,233);//这里只需要指出我们特化的double，对于int不需要指出
cout <<square.getRadius() <<endl;//会输出文本和半径
cout <<square.getArea() <<endl;//会输出文本和面积

```

## 并行编程
### 顺序，并行，并发
首先是区分顺序，并行和并发。顺序执行就是最简单的代码形式。对于并行则是在同一时间点在执行不同的任务，并发有所不同，对于单核CPU会将不同任务分配不同时间片，在不同时间片执行对应任务。
### 线程与进程
进程是程序的一次执行，线程是进程的任务流，一个进程至少需要有一个线程，也可以划分为多个子线程。
对于线程来说，它们共享全局变量，静态变量和堆空间，有各自独立的栈空间。
对于创建线程 `thread t(函数，函数所包含的参数)`
值得注意的是，如果函数参数是引用参数，就需要使用`std::ref()`来封装
```
//显然没写头文件是不严谨的
void func1(int a){
    cout <<a <<endl;
}

void func2(int &b){
    cout <<b<<endl;
}

int main(){

    thread t1(func1,100);
    int num=10;
    thread t2(func2,std::ref(num));
    if(t1.joinable()){//检验线程的可执行性
        t1.join();//等待线程运行结束
    }
    if(t2.joinable()){
        t2.join();
    }
    return 0;
}
```
对于线程还有一个函数`t.detach()`它是让主线程不在等待该线程，让该线程在后台独立执行，这样做主线程在之后并不会知道该线程的执行情况
对比`t.join()`是让主线程等待该线程的执行结束，更像是“同步”
剩下还有一些函数我直接贴上来
| 操作          | 代码示例                  | 作用                                                                 |
|---------------|---------------------------|----------------------------------------------------------------------|
| 创建线程      | `thread t(func, param)`   | 启动一个新线程，执行`func(param)`                                    |
| 等待线程结束  | `t.join()`                | 主线程阻塞，直到t执行完毕（最安全）                                  |
| 分离线程      | `t.detach()`              | 线程后台运行，主线程不等待（慎用，避免主线程先结束）                  |
| 检查线程是否可执行 | `t.joinable()`         | 返回`true`表示线程可`join()`/`detach()`，`false`表示已处理过          |
| 线程休眠      | `this_thread::sleep_for(1s)` | 当前线程休眠指定时间，让出CPU                                        |
| 获取线程ID    | `this_thread::get_id()`   | 返回当前线程的唯一标识（调试用）                                     |

### promise与future
promise与future是C++的STL工具，作用是为了获取线程中结果
可以用一段代码演示它们的作用
| 类/函数                | 作用                                                                 |
|------------------------|----------------------------------------------------------------------|
| `std::promise<T>`      | 承诺会产生一个`T`类型的结果，提供`set_value()`方法存结果             |
| `std::future<T>`       | 获取`promise`的结果，提供`get()`方法取结果（`get()`只能调用一次）|
| `promise.get_future()` | 从`promise`获取对应的`future`（一对一绑定，只能调用一次）|
| `promise.set_value()`  | 生产者线程调用，把结果存入`promise`，触发`future`变为就绪状态        |
```
int func(int a,int b,promise <int> && prom){  
int result=a+b;
prom.set_value(result);//将结果存入promise中
return result;

}


int main(){
promise <int> prom;
future <int> fu=prom.get_future();//为future赋值
thread t(func,10,20,move(prom));//因为promise不能拷贝，只能移动
cout <<fu.get() <<endl;//此过程会导致主线程阻塞,输出结果为30

if(t.joinable()){  
t.join();//等待线程结束
}    


return 0
}
```

### 互斥与锁
#### 数据竞争
在处理多线程时，根据汇编语言，各个线程会把共享变量处理后存入临界区，再拿出来，如果这个过程有多个线程在操作，这个过程可能会错误地把一个线程的临界区量取出，导致结果错误，这就是数据竞争

#### mutex
针对数据竞争，C++引入了`mutex`,具体操作如下
```
mutex mtx;//一般会设置在全局变量，不过也可以设置为一个类的隐私变量，在处理成员变量时加锁

{ //某一个作用域
mtx.lock();//加锁
操作临界区量的代码
mtx.unlock();//解锁
}

```
这个操作相当于对访问共享变量的权限进行加锁，只有拥有锁的线程才能执行这段代码，其他线程需要执行这段代码就必须等到解锁后自己拥有锁。注意只有需要执行这段代码的线程才会被阻塞，其他无关线程会正常执行
这种操作也存在危险，如果忘记解锁会导致这段代码一直被锁住，其他线程无法执行导致死锁

#### lock_guard
为了针对上述问题，可以使用`lock_guard`来完成，`lock_guard`实际上会在作用域创建一个临时变量，自动调用mtx.lock()，并且当作用域结束自动解锁
```
mutex mtx;

{//某一段作用域
lock_guard<mutex> lg(mtx);//传入相应锁
操作临界区量的代码
}//作用域结束后自动解锁

```

#### unique_lock
unique_lock有着和lock_guard同样的功能，并且可以手动加锁和解锁，使用起来更灵活，
虽然这样说，但请在真正需要使用时再仔细了解这里
| 成员函数 | 函数原型 | 功能说明 | 核心用法示例 | 注意事项 |
|----------|----------|----------|--------------|----------|
| **lock()** | `void lock()` | 手动加锁：尝试获取锁，获取不到则**阻塞当前线程**，直到拿到锁为止 | ```unique_lock<mutex> ul(mtx, defer_lock);<br>ul.lock();<br>g_num++;``` | 必须配合`std::defer_lock`构造，否则对象会自动加锁，重复lock()会崩溃 |
| **unlock()** | `void unlock()` | 手动解锁：释放持有的锁，锁回到空闲状态，其他线程可以获取 | ```ul.lock();<br>g_num++;<br>ul.unlock();``` | 只有**持有锁**时才能调用，未持有锁调用会崩溃 |
| **try_lock()** | `bool try_lock()` | 尝试加锁：**非阻塞**！能拿到锁返回`true`，拿不到返回`false`，线程不会阻塞 | ```unique_lock<mutex> ul(mtx, defer_lock);<br>if(ul.try_lock()){<br>  g_num++;<br>  ul.unlock();<br>} else {<br>  cout<<"加锁失败，执行其他逻辑";<br>}``` | 最实用的「非阻塞加锁」方式，不会让线程卡死等待 |
| 成员函数 | 函数原型 | 功能说明 | 核心用法示例 | 注意事项 |
|----------|----------|----------|--------------|----------|
| **owns_lock()** | `bool owns_lock() const` | 判断当前`unique_lock`对象**是否持有锁** | ```ul.lock();<br>if(ul.owns_lock()){<br>  g_num++;<br>  ul.unlock();<br>}``` | 返回`true`=持有锁，`false`=未持有锁；避免重复解锁/加锁的核心函数 |
| **operator bool()** | `explicit operator bool() const` | 等价于`owns_lock()`，隐式判断是否持有锁 | ```if(ul){ // 和ul.owns_lock()效果一样<br>  g_num++;<br>}``` | 语法糖，代码更简洁，和`owns_lock()`任选其一即可 |
| 成员函数 | 函数原型 | 功能说明 | 核心用法示例 | 注意事项 |
|----------|----------|----------|--------------|----------|
| **release()** | `mutex* release()` | 解除当前`unique_lock`对象和「锁对象」的绑定关系，**不会解锁**，返回锁的指针 | ```unique_lock<mutex> ul(mtx);<br>mutex* p = ul.release();<br>// 后续需要手动解锁<br>p->unlock();``` | 解绑后，对象不再管理锁，必须手动解锁，慎用！ |
| **swap()** | `void swap(unique_lock& other)` | 交换两个`unique_lock`对象持有的锁资源 | ```unique_lock<mutex> ul1(mtx1);<br>unique_lock<mutex> ul2(mtx2);<br>ul1.swap(ul2);``` | 交换后，ul1持有mtx2，ul2持有mtx1，锁的状态不变 |
### 条件变量
condition_variable条件变量是线程间同步的工具。条件变量进入等待状态时释放锁，当前线程暂停执行，在接收通知后，释放锁，继续后续操作。
condition_variable主要有两个功能wait和notify，如下：
1. wait(std::unique_lock< std::mutex>& lock) 【核心等待函数】
线程原子性释放锁 + 阻塞休眠，让出 CPU；被唤醒后必须重新竞争获取锁，拿到锁后才能继续执行，是条件变量的核心等待接口。
2. notify_one() 【核心唤醒函数】
随机唤醒一个在当前条件变量上阻塞等待的线程，唤醒后线程去竞争锁，抢到锁后校验条件。
3. notify_all() 【批量唤醒函数】
唤醒所有在当前条件变量上阻塞等待的线程，所有线程会竞争同一把锁，同一时间只有一个线程能拿到锁执行。  
  
虚假唤醒是线程在未收到任何 notify 通知的情况下，自行从 wait 中苏醒的内核底层现象，可以再使用判断条件解决
### 信号量
信号量是互斥锁的超集，对比互斥锁，信号量管理的是并发访问的数量，也就是允许同时访问共享资源的线程数量。对比于只能加锁和解锁的互斥量，信号量显然更加宽泛。使用P操作来获取（占用）一个信号量，使用V操作来增加(归还)一个信号量
对于C++来说，在C++20的版本引入了两种信号量`binary_semaphore`二元信号量和`counting_semaphore`计数信号量
对于`binary_semaphore`实际上相当于互斥锁mutex，其只有0和1两个值
```
binary_semaphore sem{1};//规定允许允许有一个线程访问共享资源
{//某一个作用域
sem.acquire();//P操作
访问共享资源的代码
sem.release();//V操作
}
```

对于`counting_semaphore`，可以有多个值，也就是允许有多个线程访问一片共享资源。`counting_semaphore sem{3}`
值得注意的是，使用`counting_semaphore`并不能保证这些线程就不会产生死锁，计数信号量只能规定访问资源的线程个数，而对内部的访问情况实际上并不了解  
  

### 异步任务
使用thread时会立刻创建线程并执行，并且并不能直接获取线程中的返回值，除了利用promise之外，也可以使用两个异步任务，`async`和`packaged_task`
#### async
`async`的基础语法为
```
future <数据类型> fu=async(执行策略，执行函数，传入参数);
fu.get();
```

`async`有三种执行策略
* `launch::async` 异步策略，执行这种策略会立刻创建线程并且执行
* `launch::deferred` 同步策略，执行这种策略不会创建线程也不会执行函数，直到fu.get()时才会开始执行
* 不写，默认策略，这取决于编译器，一般来说都会默认异步策略，不过保险起见，我们还是协商策略

`async`相当简单啊，两行代码就完成了线程的创建和返回值的获取

#### packaged_task
顾名思义，这是任务封装
有以下两种实现方式  
函数标签：返回值类型(传入参数类型)
1.   同步策略  
```
packaged_task <函数标签> task(执行函数);
future <数据类型> fu=task.get_future();
task();
fu.get();

```
2.  异步策略  
```
packaged_task<函数标签> task(执行函数);
future <数据类型> fu=task.get_future();
thread t(move(task)，传入参数);
fu.get();
```

首先可以看出`packaged_task`实际上是不能拷贝只能移动的变量，结合前面很容易理解
然后是实际上`packaged_task`支持`lambda`函数
```
packaged_task <函数标签> task([捕获外部变量类型](传入函数类型)->返回值类型{});
future <数据类型> fu=task.get_future();
task();
fu.get();
```
### 胡闹厨房
稍微谈谈我对并发编程的理解吧，其实我还挺喜欢做菜的，做菜需要讲究效率，我们可以同时做几件事，比如可以在煮饭的同时洗菜，不过有些事情又不能同时做，并且必须按次序做。比如我准备做午饭了，我首先在厨房创建了主线程，我想到应该先煮饭，创建煮饭线程，我们可以直接detach这个线程，因为煮饭不用我们管，然后开始洗菜，切肉，洗锅。一般来说我们的灶台只有两个位置，我们需要标志信号量说明最多有两个线程访问灶台共享变量，对于每一个锅共享共享变量，我们需要在使用时加锁，只有有锁的任务才能使用锅，我们开始炒菜，炒完菜并且洗锅完解锁，然后炒肉，对于这些任务我们可以使用promise或者async获得其返回值，也就是菜品，当结束后，我们使用V操作增加信号量，好的，我们做好一切后就开吃吧！
### 协程
终于将到我们实现的重点了
协程的产生是由于线程的开销实际上很大，对于更复杂的任务中断线程再创建不太现实。协程的功能是在线程中暂停，继续与保存状态的功能。
对于C++的协程有三个功能
* `co_await` 暂停并等待，实际上是最实用的功能，可以用来等待某一线程的结束或者收到某些请求
*`co_yield` 暂停并返回值 可以用来检测协程的状态
* `co_return` 结束并返回值 顾名思义，结束函数并返回值

对于C++使用协程的函数的返回值有专门的格式，比如
```
struct Generator {
    struct promise_type {
        int value;
        auto get_return_object() { return Generator{ this }; }
        auto initial_suspend() { return suspend_always{}; }
        auto final_suspend() noexcept { return suspend_always{}; }
        void unhandled_exception() { terminate(); }
        auto yield_value(int v) { value = v; return suspend_always{}; }
        void return_void() {}
    };
    coroutine_handle<promise_type> h;
    Generator(promise_type* p) : h(coroutine_handle<promise_type>::from_promise(*p)) {}
    ~Generator() { if (h) h.destroy(); }
    bool next() { h.resume(); return !h.done(); }
    int value() { return h.promise().value; }
};

//上面我也不知道是什么
Generator 函数名{
    
函数体

}


```
C++实现的协程功能确实有一点复杂，不过也代表它更具有灵活性

#### 实例
我们来实现一下记忆化递归的斐波那契函数吧
```
#include <iostream>
#include <coroutine> 
using namespace std;


struct Generator {
    struct promise_type {
        int value;
        auto get_return_object() { return Generator{ this }; }
        auto initial_suspend() { return suspend_always{}; }
        auto final_suspend() noexcept { return suspend_always{}; }
        void unhandled_exception() { terminate(); }
        auto yield_value(int v) { value = v; return suspend_always{}; }
        void return_void() {}
    };
    coroutine_handle<promise_type> h;
    Generator(promise_type* p) : h(coroutine_handle<promise_type>::from_promise(*p)) {}
    ~Generator() { if (h) h.destroy(); }
    bool next() { h.resume(); return !h.done(); }
    int value() { return h.promise().value; }
};

int Fib[100];


int fib_num(int n){
if(Fib[n]!=-1){
    return Fib[n];
}
int result=fib_num(n-1)+fib_num(n-2);
return result;
}


Generator fibnacci(int n) {
    for(int i=0;i<=n;i++){
        int val=fib_num(i);
        cout <<"当前是斐波那契" <<i <<"层:";
        co_yield val;
    }

    co_return;
}


int main() {
    int n;
    cin >>n;
for(int i=0;i<=n;i++){
    Fib[i]=-1;
}//初始化记录数组
Fib[0]=0;
Fib[1]=1;
    Generator gen = fibnacci(n);
    while (gen.next()) { 
        cout  << gen.value() << endl;
    }
    return 0;
}
```
### 计算机网路
应该需要各位稍微学习一下计算机网络的相关知识
#### 网络编程socket
`socket`即套接字，解释的话就是一套用于连接的字，`socket`是应用层用来调用传输层TCP和UDP功能的工具，从而实现两台计算机之间进程和进程之间的通信，我的理解像是接口或者类的对象，我们虽然不知道TCP三次握手四次挥手的具体实现，但我们可以通过`socket`调用暴露出来的接口，就像是通过一个类构造出来的对象来调用成员函数一样，我们虽然不知道函数的具体实现，但是可以轻松地使用这些成员函数。
使用ai稍微实现了以下Python的一对一通信
`tcp_server.py`

```
# 导入Python内置的socket库，无需安装
import socket

# 1. 创建socket类的对象，指定TCP协议（流式套接字）
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. 绑定本机IP和端口：127.0.0.1=本机，8888=自定义端口
server_addr = ('127.0.0.1', 8888)
server_socket.bind(server_addr)

# 3. 监听客户端连接，参数5代表最大等待连接数
server_socket.listen(5)
print(f"服务端启动成功！地址：{server_addr}，等待客户端连接...")

# 4. 阻塞等待客户端连接，返回：conn=通信连接对象，client_addr=客户端的IP+端口
conn, client_addr = server_socket.accept()
print(f"客户端连接成功！客户端地址：{client_addr}")

# 5. 循环收发消息
while True:
    # 接收客户端发送的消息，1024=缓冲区大小（一次最多接收1024字节）
    recv_data = conn.recv(1024)
    # 如果没收到数据/客户端退出，就终止循环
    if not recv_data:
        print("客户端已断开连接！")
        break
    # 解码字节数据为字符串，打印客户端消息
    print(f"客户端说：{recv_data.decode('utf-8')}")

    # 服务端输入消息，发送给客户端
    send_msg = input("服务端回复：")
    # 如果输入quit，就退出并关闭连接
    if send_msg == 'quit':
        conn.send(send_msg.encode('utf-8'))
        break
    # 编码字符串为字节流，发送给客户端
    conn.send(send_msg.encode('utf-8'))

# 6. 关闭连接，释放资源
conn.close()
server_socket.close()
print("服务端已关闭！")
```

`tcp_client.py`
```
# 导入Python内置的socket库
import socket

# 1. 创建socket类的对象，指定TCP协议
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. 指定要连接的服务端地址（必须和服务端一致！）
server_addr = ('127.0.0.1', 8888)

# 3. 主动向服务端发起连接请求
client_socket.connect(server_addr)
print(f"成功连接到服务端：{server_addr}，可以开始发送消息啦！输入quit退出")

# 4. 循环收发消息
while True:
    # 客户端输入消息，发送给服务端
    send_msg = input("客户端发送：")
    if send_msg == 'quit':
        client_socket.send(send_msg.encode('utf-8'))
        break
    client_socket.send(send_msg.encode('utf-8'))

    # 接收服务端的回复消息
    recv_data = client_socket.recv(1024)
    if not recv_data:
        print("服务端已断开连接！")
        break
    print(f"服务端说：{recv_data.decode('utf-8')}")

# 5. 关闭连接
client_socket.close()
print("客户端已关闭！")
```

我们最终也会实现这样类似的服务器-客户端模式

#### IO多路复用
使用上述的`socket`编程有一个问题，我们只能实现一对一的通信，当服务器与一个客户端建立连接之后，就无法与新的客户端建立通信了，并且只要客户端不发送消息就会一直陷入阻塞状态。我们当然可以建立多个线程来解决这种问题，但线程的问题是其空间开销大，且切换线程也需要一定的时间开销。IO多路复用就是在同一个主线程中，通过操作系统的内核能力，同时监控所有`socket`连接。对于IO多路复用，主线程在某个`socket`有IO事件（连接，发生数据，客户端断开时）才会工作，无事件时会阻塞。这里的阻塞并不是像前面一对一的阻塞一样，先前的阻塞会让线程卡在某一个`socket`上面，无法接收其他客户端的`socket`操作，这里的阻塞是让线程在对所有`socket`的监听上，直到有IO操作，这样做有效地减少了CPU的浪费
#### 阻塞式IO，非阻塞式IO，IO多路复用
* 阻塞式IO：阻塞 IO 会让发起 IO 的线程，从「数据就绪阶段」开始一直阻塞，直到「数据拷贝阶段」完全结束，整个期间线程完全被占用，无法处理任何其他任务。  
* 非阻塞式IO：非阻塞 IO 不会让线程一直休眠等待，而是主动轮询数据是否就绪。如果数据未就绪，函数会立刻返回，线程可以去处理其他任务；如果数据就绪，就执行数据拷贝。
缺点是轮询的频率很难把握：轮询太频繁会导致 CPU 空转（一直在问「数据好了吗」）；轮询太稀疏会导致数据就绪后不能及时处理。
* IO多路复用：IO 多路复用会把所有需要监控的 Socket 连接，交给操作系统内核统一监控（放入「监听名单」）。内核会阻塞等待，直到其中任意一个 Socket 的数据就绪，然后通知线程。
这样线程就不用自己轮询所有 Socket，只需要处理内核通知的「有事件的 Socket」，避免了 CPU 空转，同时也能让一个线程处理多个 Socket 连接。

需要明确的是阻塞/非阻塞式IO是单个`socket`的IO操作属性
而IO多路复用是管理多个IO的模式，在高性能模式下几乎是必须搭配非阻塞式IO使用
#### IO多路复用和协程
IO多路复用是内核级的IO事件监控，处理的是`socket`就绪状态的监控。协程是用户态任务调度，对任务实现挂起和恢复。
假设每个客户端对应了一个协程函数，协程函数中封装了接收数据到执行操作的一系列逻辑，IO多路复用可以通过监听哪些`socket`数据就绪，并通知线程对应的`socket`列表，根据列表线程可以找到相应客户端的协程，协程恢复，协程函数执行相应操作，完成后，协程挂起，让出CPU
二者结合使用实现了从内核到用户任务调度的流程，使用单线程高效处理了大量客户端的连接，提高CPU效率，避免CPU空转以及线程的切换与开销
